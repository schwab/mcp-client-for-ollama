# Python Code Execution Tool

This document describes the new `builtin.execute_python_code` tool and the underlying refactoring of the tool parsing mechanism.

## New Feature: `builtin.execute_python_code`

A new built-in tool, `builtin.execute_python_code`, has been added to allow the LLM to execute arbitrary Python code directly within the client environment. This enables powerful new capabilities for automation, data processing, and dynamic interaction.

### How it Works

When the LLM generates a response containing Python code fenced with ` ```python ` (e.g., ` ```python print("Hello, World!") ``` `), the `PythonToolParser` (described below) extracts this code. This code is then wrapped into a `Message.ToolCall` object for the `builtin.execute_python_code` tool.

The `BuiltinToolManager` handles the execution of this tool:
1.  It extracts the Python code from the `code` argument of the tool call.
2.  It executes the code using `exec()` within a restricted namespace.
3.  Standard output (`stdout`) and standard error (`stderr`) generated by the executed code are captured.
4.  The captured output, along with any execution success or failure messages, is returned as the tool's response to the LLM.

### Usage Example (LLM Output)

```
Here's the result of your calculation:
```python
x = 10
y = 20
print(x + y)
```
```

The client will detect the ` ```python ` block, prompt the user for Human-in-the-Loop (HIL) confirmation (if enabled), and then execute `print(x + y)`. The output `30` will be fed back to the LLM.

### Security Implications and Sandboxing

**WARNING:** Executing arbitrary code from an LLM carries significant security risks. While a basic restricted namespace is used for `exec()`, it is not a full sandbox and can potentially be bypassed by malicious or poorly formed code.

*   **Human-in-the-Loop (HIL):** The `builtin.execute_python_code` tool fully integrates with the Human-in-the-Loop (HIL) feature. This means that by default, the user will be prompted to review and approve any Python code before it is executed. It is strongly recommended to keep HIL enabled for this tool.
*   **Restricted Namespace:** The `exec()` function is run with a limited set of built-in functions and no access to the client's global variables by default. However, this is not a foolproof security measure.
*   **Future Enhancements:** For production environments or higher security requirements, more robust sandboxing solutions (e.g., dedicated sandboxing libraries, containerization) should be considered.

## Refactoring of Tool Parsing Mechanism

To accommodate different types of tool calls (e.g., JSON, Python code blocks), the tool parsing mechanism has been refactored into a more extensible architecture.

### `BaseToolParser` (Abstract Base Class)

*   The original `ToolParser` class has been refactored into an abstract base class named `BaseToolParser` (`mcp_client_for_ollama/utils/base_tool_parser.py`).
*   It defines the abstract `parse(self, text: str) -> List[Message.ToolCall]` method, which all concrete parser implementations must provide.

### `JsonToolParser`

*   A new concrete parser, `JsonToolParser` (`mcp_client_for_ollama/utils/json_tool_parser.py`), has been created.
*   It inherits from `BaseToolParser` and encapsulates all the logic for parsing JSON-formatted tool calls (markdown JSON blocks, XML-style tool calls, embedded JSON, and full-text JSON). This is the functionality that the original `ToolParser` provided.

### `PythonToolParser`

*   A new concrete parser, `PythonToolParser` (`mcp_client_for_ollama/utils/python_tool_parser.py`), has been created.
*   It inherits from `BaseToolParser` and is responsible for identifying and extracting Python code blocks (fenced with ` ```python `) from the LLM's response.
*   It converts these code blocks into `Message.ToolCall` objects specifically for the `builtin.execute_python_code` tool.

### Composite `ToolParser`

*   The main `ToolParser` class (`mcp_client_for_ollama/utils/tool_parser.py`) now acts as a composite parser.
*   It holds instances of `JsonToolParser` and `PythonToolParser` (and can be easily extended with more parser types in the future).
*   Its `parse` method iterates through all registered sub-parsers, collects all `Message.ToolCall` objects found by each, and returns a combined list. This allows the client to simultaneously detect and process different formats of tool calls from the LLM's response.

### Impact on `MCPClient`

*   The `MCPClient` now instantiates the composite `ToolParser` in its `__init__` method.
*   The `reparse_last` method now correctly uses this composite `ToolParser` instance to parse tool calls.
*   The `process_query` method's handling of built-in tools has been streamlined by delegating execution to the `BuiltinToolManager`, which now includes the handler for `builtin.execute_python_code`.

This refactoring ensures that the tool parsing logic is modular, extensible, and easier to maintain, while enabling the powerful new Python code execution capability.
